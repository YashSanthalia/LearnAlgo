{"ast":null,"code":"export function initializePopulation(population, order, populationSize) {\n  for (let i = 0; i < populationSize; i++) {\n    population[i] = shuffle(order);\n  }\n}\n\nfunction shuffle(order) {\n  let array = order.slice();\n  array.sort(() => Math.random() - 0.5);\n  return array;\n}\n\nexport function calcFitness(points, population, fitness) {\n  for (let i = 0; i < population.length; i++) {\n    let d = calcDist(points, population[i]);\n    fitness[i] = 1 / (d + 0.1);\n  }\n\n  normalizeFitness(fitness);\n}\n\nfunction normalizeFitness(fitness) {\n  let totalFitness = 0;\n\n  for (let i = 0; i < fitness.length; i++) {\n    totalFitness += fitness[i];\n  }\n\n  for (let i = 0; i < fitness.length; i++) {\n    fitness[i] = fitness[i] / totalFitness;\n  }\n}\n\nfunction calcDist(points, order) {\n  let sum = 0;\n\n  for (let i = 1; i < order.length; i++) {\n    let x1 = points[order[i]].x;\n    let y1 = points[order[i]].y;\n    let x2 = points[order[i - 1]].x;\n    let y2 = points[order[i - 1]].y;\n    let x = x1 - x2;\n    let y = y1 - y2;\n    let d = Math.sqrt(x * x + y * y);\n    sum += d;\n  }\n\n  return sum;\n}\n\nexport function getCurrentBest(fitness) {\n  let index = -1;\n  let best = -1;\n\n  for (let i = 0; i < fitness.length; i++) {\n    if (fitness[i] > best) {\n      best = fitness[i];\n      index = i;\n    }\n  }\n\n  return index;\n}\nexport function nextGeneration(population, fitness) {\n  let newPopulation = [];\n\n  for (let i = 0; i < population.length; i++) {\n    let order1 = getOne(population, fitness);\n    let order2 = getOne(population, fitness);\n    let newOrder = crossOver(order1, order2);\n    newOrder = mutate(newOrder, 0.01);\n    newPopulation.push(newOrder);\n  }\n\n  return newPopulation;\n}\n\nfunction getOne(list, prob) {\n  var index = 0;\n  var r = Math.random(1);\n\n  while (r > 0) {\n    r = r - prob[index];\n    index++;\n  }\n\n  index--;\n  return list[index].slice();\n}\n\nfunction crossOver(order1, order2) {\n  var start = Math.floor(Math.random(1) * order1.length);\n  var end = Math.floor(Math.random(1) * (order1.length - (start + 1) + 1) + start + 1);\n  var temp = order1.slice(start, end);\n  let newOrder = [];\n\n  for (let i = 0; i < order1.length; i++) {\n    newOrder[i] = Infinity;\n  }\n\n  for (let i = start; i < end; i++) {\n    newOrder[i] = order1[i];\n  }\n\n  let j = 0;\n\n  for (let i = 0; i < order2.length; i++) {\n    var idx = order2[i];\n    if (j === start) j = end;\n\n    if (!temp.includes(idx)) {\n      newOrder[j] = idx;\n    }\n\n    j += 1;\n  }\n\n  return newOrder;\n}\n\nfunction mutate(order, mutationRate) {\n  for (var i = 0; i < order.length; i++) {\n    if (Math.random(1) < mutationRate) {\n      var indexA = Math.floor(Math.random(1) * order.length);\n      var indexB = (indexA + 1) % order.length;\n      order = swap(order, indexA, indexB);\n    }\n  }\n\n  return order;\n}\n\nfunction swap(order, i, j) {\n  let temp = order[i];\n  order[i] = order[j];\n  order[j] = temp;\n  return order;\n}","map":{"version":3,"sources":["C:/Users/yash santhalia/Desktop/React/algo/src/TSP/GeneticAlgo.js"],"names":["initializePopulation","population","order","populationSize","i","shuffle","array","slice","sort","Math","random","calcFitness","points","fitness","length","d","calcDist","normalizeFitness","totalFitness","sum","x1","x","y1","y","x2","y2","sqrt","getCurrentBest","index","best","nextGeneration","newPopulation","order1","getOne","order2","newOrder","crossOver","mutate","push","list","prob","r","start","floor","end","temp","Infinity","j","idx","includes","mutationRate","indexA","indexB","swap"],"mappings":"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","sourcesContent":["export function initializePopulation(population, order, populationSize) {\r\n  for (let i = 0; i < populationSize; i++) {\r\n    population[i] = shuffle(order);\r\n  }\r\n}\r\n\r\nfunction shuffle(order) {\r\n  let array = order.slice();\r\n  array.sort(() => Math.random() - 0.5);\r\n  return array;\r\n}\r\n\r\nexport function calcFitness(points, population, fitness) {\r\n  for (let i = 0; i < population.length; i++) {\r\n    let d = calcDist(points, population[i]);\r\n    fitness[i] = 1 / (d + 0.1);\r\n  }\r\n  normalizeFitness(fitness);\r\n}\r\n\r\nfunction normalizeFitness(fitness) {\r\n  let totalFitness = 0;\r\n  for (let i = 0; i < fitness.length; i++) {\r\n    totalFitness += fitness[i];\r\n  }\r\n  for (let i = 0; i < fitness.length; i++) {\r\n    fitness[i] = fitness[i] / totalFitness;\r\n  }\r\n}\r\n\r\nfunction calcDist(points, order) {\r\n  let sum = 0;\r\n  for (let i = 1; i < order.length; i++) {\r\n    let x1 = points[order[i]].x;\r\n    let y1 = points[order[i]].y;\r\n    let x2 = points[order[i - 1]].x;\r\n    let y2 = points[order[i - 1]].y;\r\n    let x = x1 - x2;\r\n    let y = y1 - y2;\r\n    let d = Math.sqrt(x * x + y * y);\r\n    sum += d;\r\n  }\r\n  return sum;\r\n}\r\n\r\nexport function getCurrentBest(fitness) {\r\n  let index = -1;\r\n  let best = -1;\r\n  for (let i = 0; i < fitness.length; i++) {\r\n    if (fitness[i] > best) {\r\n      best = fitness[i];\r\n      index = i;\r\n    }\r\n  }\r\n  return index;\r\n}\r\n\r\nexport function nextGeneration(population, fitness) {\r\n  let newPopulation = [];\r\n  for (let i = 0; i < population.length; i++) {\r\n    let order1 = getOne(population, fitness);\r\n    let order2 = getOne(population, fitness);\r\n    let newOrder = crossOver(order1, order2);\r\n    newOrder = mutate(newOrder, 0.01);\r\n    newPopulation.push(newOrder);\r\n  }\r\n  return newPopulation;\r\n}\r\n\r\nfunction getOne(list, prob) {\r\n  var index = 0;\r\n  var r = Math.random(1);\r\n\r\n  while (r > 0) {\r\n    r = r - prob[index];\r\n    index++;\r\n  }\r\n  index--;\r\n  return list[index].slice();\r\n}\r\n\r\nfunction crossOver(order1, order2) {\r\n  var start = Math.floor(Math.random(1) * order1.length);\r\n  var end = Math.floor(Math.random(1) * (order1.length - (start + 1) + 1) + start + 1);\r\n  var temp = order1.slice(start, end);\r\n  let newOrder = [];\r\n  for (let i = 0 ; i < order1.length ; i++) {\r\n    newOrder[i] = Infinity;\r\n  }\r\n  for (let i = start; i < end; i++) {\r\n    newOrder[i] = order1[i];\r\n  }\r\n  let j = 0;\r\n  for (let i = 0; i < order2.length; i++) {\r\n    var idx = order2[i];\r\n    if (j === start) j = end;\r\n    if (!temp.includes(idx)) {\r\n      newOrder[j] = idx;\r\n    }\r\n    j += 1;\r\n  }\r\n  return newOrder;\r\n}\r\n\r\nfunction mutate(order, mutationRate) {\r\n  for (var i = 0; i < order.length; i++) {\r\n    if (Math.random(1) < mutationRate) {\r\n      var indexA = Math.floor(Math.random(1) * order.length);\r\n      var indexB = (indexA + 1) % order.length;\r\n      order = swap(order, indexA, indexB);\r\n    }\r\n  }\r\n  return order;\r\n}\r\n\r\nfunction swap(order, i, j) {\r\n  let temp = order[i];\r\n  order[i] = order[j];\r\n  order[j] = temp;\r\n  return order;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}