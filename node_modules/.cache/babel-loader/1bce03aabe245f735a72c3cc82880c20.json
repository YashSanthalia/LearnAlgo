{"ast":null,"code":"export function initializePopulation(population, order, populationSize) {\n  for (let i = 0; i < populationSize; i++) {\n    population[i] = shuffle(order);\n  }\n}\n\nfunction shuffle(order) {\n  let array = order.slice();\n  array.sort(() => Math.random() - 0.5);\n  return array;\n}\n\nexport function calcFitness(points, population, fitness) {\n  for (let i = 0; i < population.length; i++) {\n    let d = calcDist(points, population[i]);\n    fitness[i] = 1 / (d + 0.1);\n  }\n\n  normalizeFitness(fitness);\n}\n\nfunction normalizeFitness(fitness) {\n  let totalFitness = 0;\n\n  for (let i = 0; i < fitness.length; i++) {\n    totalFitness += fitness[i];\n  }\n\n  for (let i = 0; i < fitness.length; i++) {\n    fitness[i] = fitness[i] / totalFitness;\n  }\n}\n\nfunction calcDist(points, order) {\n  let sum = 0;\n\n  for (let i = 1; i < order.length; i++) {\n    let x1 = points[order[i]].x;\n    let y1 = points[order[i]].y;\n    let x2 = points[order[i - 1]].x;\n    let y2 = points[order[i - 1]].y;\n    let x = x1 - x2;\n    let y = y1 - y2;\n    let d = Math.sqrt(x * x + y * y);\n    sum += d;\n  }\n\n  return sum;\n}\n\nexport function getCurrentBest(fitness) {\n  let index = -1;\n  let best = -1;\n\n  for (let i = 0; i < fitness.length; i++) {\n    if (fitness[i] > best) {\n      best = fitness[i];\n      index = i;\n    }\n  }\n\n  return index;\n}\nexport function nextGeneration(population, fitness) {\n  let newPopulation = [];\n\n  for (let i = 0; i < population.length; i++) {\n    let order1 = getOne(population, fitness);\n    let order2 = getOne(population, fitness);\n    let newOrder = crossOver(order1, order2);\n    newOrder = mutate(newOrder, 0.05);\n    newPopulation.push(newOrder);\n  }\n\n  return newPopulation;\n}\n\nfunction getOne(list, prob) {\n  var index = 0;\n  var r = Math.random(1);\n\n  while (r > 0) {\n    r = r - prob[index];\n    index++;\n  }\n\n  index--;\n  return list[index].slice();\n}\n\nfunction crossOver(order1, order2) {\n  var start = Math.floor(Math.random(1) * order1.length);\n  var end = Math.floor(Math.random(1) * (order1.length - (start + 1) + 1) + start + 1);\n  var neworder = order1.slice(start, end);\n\n  for (var i = 0; i < order2.length; i++) {\n    var idx = order2[i];\n\n    if (!neworder.includes(idx)) {\n      neworder.push(idx);\n    }\n  }\n\n  return neworder;\n}\n\nfunction mutate(order, mutationRate) {\n  for (var i = 0; i < totalCities; i++) {\n    if (Math.random(1) < mutationRate) {\n      var indexA = Math.floor(Math.random(1) * order.length);\n      var indexB = (indexA + 1) % totalCities;\n      order = swap(order, indexA, indexB);\n    }\n  }\n\n  return order;\n}\n\nfunction swap(order, i, j) {\n  let temp = order[i];\n  order[i] = order[j];\n  order[j] = temp;\n  return order;\n}","map":{"version":3,"sources":["C:/Users/yash santhalia/Desktop/React/algo/src/TSP/GeneticAlgo.js"],"names":["initializePopulation","population","order","populationSize","i","shuffle","array","slice","sort","Math","random","calcFitness","points","fitness","length","d","calcDist","normalizeFitness","totalFitness","sum","x1","x","y1","y","x2","y2","sqrt","getCurrentBest","index","best","nextGeneration","newPopulation","order1","getOne","order2","newOrder","crossOver","mutate","push","list","prob","r","start","floor","end","neworder","idx","includes","mutationRate","totalCities","indexA","indexB","swap","j","temp"],"mappings":"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","sourcesContent":["export function initializePopulation(population, order, populationSize) {\r\n  for (let i = 0; i < populationSize; i++) {\r\n    population[i] = shuffle(order);\r\n  }\r\n}\r\n\r\n\r\nfunction shuffle(order) {\r\n    let array = order.slice();\r\n    array.sort(() => Math.random() - 0.5);\r\n    return array;\r\n}\r\n\r\nexport function calcFitness(points, population, fitness) {\r\n  for (let i = 0; i < population.length; i++) {\r\n      let d = calcDist(points, population[i]);\r\n      fitness[i] = 1/(d + 0.1);\r\n  }\r\n  normalizeFitness(fitness);\r\n}\r\n\r\nfunction normalizeFitness(fitness){\r\n    let totalFitness = 0;\r\n    for(let i =  0 ; i < fitness.length ; i++){\r\n        totalFitness += fitness[i]; \r\n    }\r\n    for(let i =  0 ; i < fitness.length ; i++){\r\n        fitness[i] = fitness[i] / totalFitness; \r\n    }\r\n\r\n}\r\n\r\nfunction calcDist(points, order){\r\n    let sum = 0;\r\n    for(let i = 1 ; i < order.length ; i++){\r\n        let x1 = points[order[i]].x;\r\n        let y1 = points[order[i]].y;\r\n        let x2 = points[order[i-1]].x;\r\n        let y2 = points[order[i-1]].y;\r\n        let x = x1-x2;\r\n        let y = y1-y2;\r\n        let d = Math.sqrt(x*x + y*y);\r\n        sum += d;\r\n    }\r\n    return sum;\r\n}\r\n\r\nexport function getCurrentBest(fitness){\r\n    let index = -1;\r\n    let best = -1;\r\n    for(let i = 0 ; i < fitness.length ; i++){\r\n        if(fitness[i] > best){\r\n            best = fitness[i];\r\n            index = i;\r\n        }\r\n    }\r\n    return index;\r\n}\r\n\r\nexport function nextGeneration(population, fitness){\r\n    let newPopulation = [];\r\n    for(let i = 0 ; i < population.length ; i++){\r\n        let order1 = getOne(population, fitness);\r\n        let order2 = getOne(population, fitness);\r\n        let newOrder = crossOver(order1, order2);\r\n        newOrder = mutate(newOrder, 0.05);\r\n        newPopulation.push(newOrder);\r\n    } \r\n    return newPopulation;\r\n}\r\n\r\nfunction getOne(list, prob) {\r\n    var index = 0;\r\n    var r = Math.random(1);\r\n  \r\n    while (r > 0) {\r\n      r = r - prob[index];\r\n      index++;\r\n    }\r\n    index--;\r\n    return list[index].slice();\r\n  }\r\n\r\n  function crossOver(order1, order2) {\r\n    var start = Math.floor(Math.random(1) * order1.length);\r\n    var end = Math.floor(Math.random(1) * (order1.length - (start+1) + 1) + start + 1);\r\n    var neworder = order1.slice(start, end);\r\n    for (var i = 0; i < order2.length; i++) {\r\n      var idx = order2[i];\r\n      if (!neworder.includes(idx)) {\r\n        neworder.push(idx);\r\n      }\r\n    }\r\n    return neworder;\r\n  }\r\n  \r\n  function mutate(order, mutationRate) {\r\n    for (var i = 0; i < totalCities; i++) {\r\n      if (Math.random(1) < mutationRate) {\r\n        var indexA = Math.floor(Math.random(1) * order.length);\r\n        var indexB = (indexA + 1) % totalCities;\r\n        order = swap(order, indexA, indexB);\r\n      }\r\n    }\r\n    return order;\r\n  }\r\n\r\n  function swap(order, i, j){\r\n      let temp = order[i];\r\n      order[i] = order[j];\r\n      order[j] = temp;\r\n      return order;\r\n  }"]},"metadata":{},"sourceType":"module"}